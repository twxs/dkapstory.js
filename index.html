<!doctype html>
<html>
<head>
    <title>D-Kapstory</title>
    <meta charset="utf-8">

    <script src="./vendor/three.js/three.min.js"></script>
    
    <script src="./js/dk.js"></script>
    <link href="css/main.css" rel="stylesheet" />
</head>
<body>

    <div id="container" width="512" height="512"></div>


    <script type="text/javascript">
         /*global THREE getClass DFK*/
         
        var factory = new DFK.Factory();
        
        factory.add("mesh::caps", function()
        {
            return makeCaps();
        });
        
        
        function df_caps_animator(capsCount, pos) {
            var d =  {};
            d.obj = new THREE.Object3D();
            
            d.particules = [];

            for (var i = 0; i < capsCount; ++i) {
                
                d.obj.add(factory.create("mesh::caps")());

                var part = new DFK.particule(
                    0.32, 
                    DFK.P, 
                    {
                        onDie : function (part) {
                                    var min = 5;
                                    if (part.v.y < min) // Full reset
                                        part.reset(DFK.v3(pos.x + DFK.rnd(-1, 1), 
                                                          pos.y + DFK.rnd(0, 1), 
                                                          pos.z),
                                                   DFK.v3(Math.sin(DFK.rnd(-3.1415, 3.1415)), 
                                                          4 + DFK.rnd(-1, 1.5), 
                                                          Math.cos(DFK.rnd(-3.1415, 3.1415))));
                                    else // bounce
                                    {
                                        part.p.y = min;
                                        part.reset(part.p, DFK.v3(2*part.v.x, 
                                                                  0.7*part.v.y, 
                                                                  2*part.v.z));
                                    }
                                },
                        shouldDie : function(p, v) { return p.y < 0; }
                    });


                d.particules.push(part);
            }

            d.animate = function (dt) {
                for (var i = 0; i < d.particules.length; ++i) {
                    // get the new particule position
                    var new_pos = d.particules[i].next(dt);
                    
                    var mesh = d.obj.children[i];
                    //update the mesh position and little hack on the rotation
                    mesh.position.set(new_pos.x, new_pos.y, new_pos.z);
                    mesh.rotation.x = new_pos.z / 10;
                    mesh.rotation.z = new_pos.y / 10;
                }
            }
            return d;
        }

        


        var renderer, scene, camera, bottle, caps, mycaps, animator;

        init();
        document.addEventListener('mousemove', onDocumentMouseMove, false);
        animate();


        function makeBottle() {
            var baseradius = 10;
            var topradius = 5;
            var baseheight = 30;
            var topheight = 10;
            var ringheight = 2;
            var ringradius = 5.5;

            var base, top, ring;


            var material = new THREE.MeshLambertMaterial({ color: 0xCCFCC0 });


            var bottle = new THREE.Object3D();


            base = new THREE.Mesh(new THREE.CylinderGeometry(baseradius, baseradius, baseheight, 10, 10), material);
            base.position.y = baseheight / 2;

            top = new THREE.Mesh(new THREE.CylinderGeometry(topradius, baseradius, topheight, 10, 10), material);
            top.position.y = baseheight + topheight / 2;

            ring = new THREE.Mesh(new THREE.CylinderGeometry(ringradius, ringradius, ringheight, 10, 10), material);
            ring.position.y = baseheight + topheight + ringheight / 2;


            base.castShadow = true;
            top.castShadow = true;
            ring.castShadow = true;

            base.receiveShadow = true;
            top.receiveShadow = true;
            ring.receiveShadow = true;

            bottle.add(top)
            bottle.add(base)
            bottle.add(ring)
            return bottle;
        }

        function makeCaps() {
            var material = new THREE.MeshLambertMaterial({ color: 0xFC0C20 });
            var geometry;

            if(!factory.contains("geom::caps"))
            {
                geometry = new THREE.CylinderGeometry(6, 6.2, 2);
                factory.add("geom::caps", geometry);
            }
            var ring = new THREE.Mesh(factory.create("geom::caps"), material);
            return ring;
        }

        function onDocumentMouseMove(event) {

            event.preventDefault();

            var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
            var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

            mycaps.position.x += movementX * 0.1;
            mycaps.position.y += movementY * 0.1;

            render();

        }

        function df_dlight(lightPos, lightTarget, floorRadius) {
           

            var lightDir = DFK.v3(lightTarget.x - lightPos.x, lightTarget.y - lightPos.y, lightTarget.z - lightPos.z);
            var dist = Math.sqrt(lightDir.x * lightDir.x + lightDir.y * lightDir.y + lightDir.z * lightDir.z);
            document.title = lightDir.x;
            var light = new THREE.DirectionalLight(0x444444);

            light.position.set(lightPos.x, lightPos.y, lightPos.z);
            light.target.position.set(lightTarget.x, lightTarget.y, lightTarget.z);

            light.castShadow = true;
            light.shadowDarkness = 0.5;
            //light.shadowCameraVisible = true; // only for debugging
            // these six values define the boundaries of the yellow box seen above
            light.shadowCameraNear = dist - floorRadius;
            light.shadowCameraFar = dist + floorRadius;
            light.shadowCameraLeft = -floorRadius;
            light.shadowCameraRight = floorRadius;
            light.shadowCameraTop = floorRadius;
            light.shadowCameraBottom = -floorRadius;
            return light;

        }


        function init() {
            // on initialise le moteur de rendu
            renderer = new THREE.WebGLRenderer();

            // si WebGL ne fonctionne pas sur votre navigateur vous pouvez utiliser le moteur de rendu Canvas à la place
            // renderer = new THREE.CanvasRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            // on initialise la scène
            scene = new THREE.Scene();

            // on initialise la camera que l’on place ensuite sur la scène
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(0, 150, 250);
            // camera.rotation.x = -0.25;
            camera.lookAt(new THREE.Vector3(0.0, 50.0, 0.0));
            scene.add(camera);

            bottle = makeBottle();
            caps = makeCaps();
            mycaps = makeCaps();
            caps.position.y = 42;
            mycaps.position.y = 50;
            mycaps.position.z = 20;
            mycaps.position.x = 7;
            scene.add(bottle);
            scene.add(caps);
            scene.add(mycaps);

            var capsule = factory.create("mesh::caps")();
            capsule.position.set(20, 20, 20);
            


            animator = new df_caps_animator(200, new THREE.Vector3(0, 48, 0));
            scene.add(animator.obj);

            var floorRadius = 200;
            /* Floor  */
            var geometry = new THREE.CylinderGeometry(floorRadius, floorRadius, 0.1, 20, 8);
            var material = new THREE.MeshPhongMaterial({ color: 0x42AF33 });
            var floor = new THREE.Mesh(geometry, material);
            floor.material.side = THREE.DoubleSide;
            //floor.rotation.x = 3.1415 / 2;
            scene.add(floor);

            var lightPos = DFK.v3(floorRadius + 50, 2*floorRadius, 0.5*floorRadius + 50);
          
            scene.add(df_dlight(lightPos, DFK.v3(0, 30, 0), floorRadius));
            lightPos.x *= -1;
            scene.add(df_dlight(lightPos, DFK.v3(0, 30, 0), floorRadius));
            lightPos.z *= -1;
            scene.add(df_dlight(lightPos, DFK.v3(0, 30, 0), floorRadius));
            lightPos.x *= -1;
            scene.add(df_dlight(lightPos, DFK.v3(0, 30, 0), floorRadius));

            bottle.receiveShadow = true;
            caps.castShadow = true;
            caps.receiveShadow = true;
            mycaps.receiveShadow = true;
            mycaps.castShadow = true;

            floor.receiveShadow = true;
            // add to the scene



            renderer.shadowMapEnabled = true;
            renderer.shadowMapSoft = true;

            renderer.shadowCameraNear = camera.near;
            renderer.shadowCameraFar = camera.far;
            renderer.shadowCameraFov = 50;

            renderer.shadowMapBias = 0.0039;
            renderer.shadowMapDarkness = 0.5;
            renderer.shadowMapWidth = 1024;
            renderer.shadowMapHeight = 1024;


            // on effectue le rendu de la scène
            //renderer.render( scene, camera );
        }
        var gt = 0;
        function animate() {

            // note: three.js includes requestAnimationFrame shim
            requestAnimationFrame(animate);

            animator.animate(0.10510);
            gt += 0.02510;

            camera.position.set((150 + 50*Math.cos(gt/3))*Math.sin(gt), 150 + 100*(1+Math.sin(gt)), (250 + 50*Math.sin(gt/3))*Math.cos(gt));
            camera.lookAt(new THREE.Vector3(0.0, 50.0, 0.0));
            render();

        }

        function render() {

            // mesh.rotation.x += 0.01;
            //mesh.rotation.y += 0.02;
            renderer.setClearColor(0);
            renderer.render(scene, camera);

        }
    </script>
</body>
</html>